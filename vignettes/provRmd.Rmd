---
title: "Provenance tracking in RMarkdown using provRmd"
author: "Casey O'Hara"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Intro to provenance

The Ocean Health Index strives toward the ideals of open science: access, transparency, reproducibility, and repeatability.  In our global assessment and regional assessments, we have increasingly been using R Markdown to document our work flow, data preparation, and score calculation, while using GitHub as a version control system as well as a means of making our work freely accessible.

One important aspect of reproducibility is the ability to follow data from raw sources to finished product, be it a graph, a calculation, a synthesized dataset, or an OHI score.  GitHub affords a limited ability to track the creation and modification of datasets, scripts, figures, and documents, but as multiple sources are combined, it may be impossible to pick apart which version of dataset A was used by which version of script B to create figure C and output data D.  This becomes even further complicated by the fact that differences in versions of base software, packages, and systems can create minor or major differences in the outcomes.

The `provRmd` package attempts to capture the necessary information to exactly reproduce the results of each specific run of an R Markdown script, by tracing data as they are brought into the parent Rmd, processed in code chunks or sourced scripts, and written out as intermediate or final products.

The `provRmd` package captures two types of provenance at once:

* Runtime provenance is a tracing of a specific run of a script, capturing versions and conditions to enable reproducibility of the results of that particular run.  This includes version tracking of input data files, scripts, output files, packages, software, and operating system.
* Workflow provenance is a conceptual understanding of the process, similar to a flow chart.  Which files were used by which scripts or code chunks, and which outputs were generated.

## How does `provRmd` work

Each time an R Markdown document is knit, `provRmd` collects information on each input, output, and script file to tie it to its most recent Git commit.  At the end of the knit, this sequence of filenames with their associated Git commit information are wrapped up with information about the system and session in which the R Markdown doc was knit.  This provenance log is saved to a .csv, and can be displayed directly in the knitted document, e.g. as a flow chart or a data table.

By recreating the conditions of a particular run, it should be reasonably simple to replicate the output or process.

Note that `provRmd` only works within the context of knitting an R Markdown document.  

## Using `provRmd`

### Setting up provenance tracking

The first step in using `provRmd` is to initialize the global variables that will track the process as the Rmd knits.  The `prov_setup()` function performs this, and should be called early in the R Markdown document, before any important files are read or sourced.  If you are using packages with read/write capabilities (e.g. `readr`), it is helpful to load `provRmd` afterward so the automatic provenance tracking masks the basic definition.

``` {r setup, echo = TRUE, warning = FALSE, message = FALSE}
library(dplyr); library(tidyr); library(readr)

library(provRmd)

prov_setup()
```

### Capturing provenance of inputs, outputs, and scripts

As the knitting process proceeds, each time one of the registered functions is used to read or write data, e.g. `read.csv()` or `writeOGR()`, that function will be performed as normal but then will follow up with an embedded call to `git_prov()`, which uses the file name to query the latest Git commit information.  If no Git information is available (e.g. the file has never been committed, or the file exists outside the current Git repository) then the file will be logged with NAs instead.  

As the script runs, file provenance info is stored in a hidden global object, `.prov_track`, which can be accessed like any R object.

``` {r git_prov example, echo = TRUE, message = FALSE, warning = FALSE}
prov_setup()

spp_df <- read_csv('spp_table1.csv')

spp_df <- spp_df %>%
  mutate(risk = ifelse(status > .15, 'high', 'low'))

write_csv(spp_df, 'spp_table2.csv')

names(.prov_track)

knitr::kable(.prov_track[, 1:5])
```

Note that `git_prov()` can be called manually, for example when calling a read/write function that is not in the `git_prov_fun` registry.  It may be useful as well to assign a particular file to various roles within the script, e.g. one code chunk creates an object and writes it as an output, and the next code chunk uses it as an input without calling a read function.  In that case, only the write function will be automatically logged.

When sourcing external scripts, `git_prov()` will capture provenance for the sourced script, and then associate inputs and outputs to that script, rather than to the parent.

``` {r git_prov source example, echo = TRUE, message = FALSE, warning = FALSE}

source('source_example.R')

knitr::kable(.prov_track[, 1:5])
```

### Wrapping up provenance tracking

At the end of the R Markdown document, the `script_prov()` function collects the sequence of information from all calls to `git_prov()`, attaches system information (from `Sys.info()`) and session information (from `sessionInfo()`), and writes out the log file to the prov directory within the working directory of the parent R Markdown document.  This information is stored in a dataframe object called `.script_track`.  In addition, `script_prov()` returns (invisibly) a named list object containing information about the session and system. 

``` {r script_prov example, echo = TRUE, message = FALSE, warning = FALSE}

script_out_df <- script_prov() 

names(script_out_df)
```

The named list items can be called within the R Markdown document to print system/session info.  For example: 

* `script_out_df$msg_sys` prints: 
    * `r script_out_df$msg_sys`
* `script_out_df$msg_att_pkgs` prints: 
    * `r script_out_df$msg_att_pkgs`
    
Just as `.prov_track` can be accessed directly, we can also view the contents of `.script_prov`:

``` {r view script_track}
names(.script_track)

knitr::kable(.script_track[, 4:9] %>%
               arrange(sequence))
```

While `script_prov()` saves the log file for later review, it may also be helpful to include provenance information directly in the knitted output from the R Markdown doc.  Several pre-built footers are included in the package; these footers can be attached as "child" using a simple code chunk.  The footers include the call to `script_prov()` and will include provenance information as text, tables, and/or flow charts at the end of the knitted document.

### Creating provenance flow charts

The `plot_prov()` function uses the `.script_track` dataframe to link inputs, outputs, code chunks, and sourced scripts into a conceptual flow chart.  

``` {r plot_prov}
plot_obj <- plot_prov(df = .script_track, plot_dir = 'TB')

DiagrammeR::render_graph(plot_obj)
```

Red frames indicate files not currently tracked in Git; yellow frames indicate files whose contents have changed since the most recent Git commit.

## Good practices

### Naming code chunks
To gain the most granularity in the workflow provenance documentation of your R Markdown process, it is helpful to break up R code into small, meaningful chunks; each chunk might take in some inputs and create some outputs.  Since `provRmd` tracks each chunk separately, it is helpful to give each a short but meaningful name; unnamed chunks will default to `unnamed_chunk_1` and so on.

### Linking objects passed between code chunks

While R easily holds objects created in one chunk so they may be used in another chunk, this breaks the link of the flow of the data.  One way around this is to have each chunk write out its result object, for example using `write_csv()`, and then have the next chunk read the object back into memory, for example using `read_csv()`.  While this seems redundant, it makes sure that the object is registered as an output from one chunk and then as an input to the next.  

```
basic example of how not to do it; then example of how to do it. INCLUDE WORKFLOW PROV CHART
```

This can also be accomplished by writing the result object in the first chunk and then simply calling `git_prov()` using the file name of the written object, with `filetype = 'input'`.  This does not reload the object from memory, but still registers the object as an input to the second chunk.

```
basic example again
```

Sometimes you'd like to avoid re-running a time-consuming process each time the master Rmd is knitted, for example by including an `if(file.exists(filename))` to see if a large raster file already exists before recreating it.  In such a situation where that file already exists, it may be helpful to include a `git_prov()` call (with `filetype = 'output'`) to register that it would normally be created within that code chunk, even if it was not recreated during that particular run.

```
example
``` 

## script_prov() standalone and in footers

### manual script_prov()

### manual plot_prov()

### creating custom footers
